Command Prompt:
- py -3.7 namefile.py
- conda activate base

Division:
- d divise n implique n/d divise n
- donc les diviseurs de n sont inférieurs ou égaux à sqrt(n)
- x += a % 2 n'est pas équivalent ) x = (x + a) % 2

Fast Input:
- import io, os
  input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline - à mettre au début
  s = input().decode()
  print(s)
- import sys
  #read a line
  input = sys.stdin.readline()
  #read the whole file
  for line in sys.stdin

Fast Output:
- import sys
- s = "sidney"
  sys.stdout.write(s + "\n") (le retour à la ligne doit se faire manuellement)
- for array:
  sys.stdout.write(" ".join(map(str, L)) + "\n)
- for int:
  s = 5
  sys.stdout.write(str(s))
- f"{number:nF}" genre n chiffre après la virgule, python format

Int:
- int(str, base)

Dict:
- d.setdefault(clef, valeur si pas de clef) renvoie la valeur correspondant à la clef si pas
  de clef, crée cette crée et lui assigne la valeur donnée
- d.get(clef) renvoie la valeur correspondant à la clef
- d[clef] équivaut à L[i]
- définir un dict : d = {clef1 : valeur1, clef2 : valeur2}
- pop(), removes the element with the specified key
- values(), return a list of all the values in the dictionary
- keys(), renvoie un object dict_keys
- if x in d: le if porte sur les clefs

List:
- sorted(L) renvoie la liste L triée
- on peut sort des listes de mots par ordre alphabétique avec L.sort()
- L.reverse()
- L.index(value)
- L.insert(index, value)
- L.count(value)
- On peut prendre le min ou max d'une liste de caractères

Set:
- set(itérable) renvoie un set sans doublons
- set(str) renvoie un set des lettres sans doublons
- méthodes sur les set:
  - add()
  - clear(), supprime tous les éléments
  - copy(), renvoie la copie d'un ensemble
  - difference, la différence de 2 ensembles
  - intersection(), intersection de deux ensembles
  - pop(), un élément aléatoire
  - remove(a) enlève l'élément a du set
  - union(), union de deux ensembles
  - isdisjoint() True si disjoint
  - issubset() True si sous-ensemble
  - issuperset() True si est contenu par l'ensemble

Print:
- print("Hello there!", end = '') if don't want to go new line
  by default end = "\n"
- type return ends a function

Priority queue:
- from queue import PriorityQueue
- queue = PriorityQueue(maxsize = 0)
- methods:
  - put(), puts an item into the queue
  - get(), removes and returns an item form the queue
  - qsize(), returns the current queue size 
  - empty(), returns True if the queue is empty, False otherwise
  - full(), returns True if the queue is full, false otherwise

Queus (FIFO or LIFO):
- from collections import deque
- queue = deque(itérable ou rien)
- methods:
  - append()
  - appendleft()
  - count(x), compte les éléments égaux à x
  - extend(itérable), étend la deque avec l'itérable à droite
  - extendleft(itérable), idem
  - pop(), retire élément de droite
  - popleft(), retire élément de gauche

Stratégie Optimate dans un jeu :
- Faire du backtracking

Optimisation:
- Essayer d'update les structures pour chaque input, closestsums

Combinaisons:
- from itertools import combinations, renvoie itérable combination(itérable, nb element dans la combinaison)

Brute Force:
- Parcours de Graphe
- Si on veut le minimum : Dijkstra

Graphes:
- naif : V = [1 2 3 4 5], E = [(1, 4) ...]
- listes d'adjacence : E = [[4,2], ...]
- liste set E = [{4, 2}, ...]
- matrices d'adjacence : M[i][j] = 1 si (i, j) in E 0 sinon

Dijkstra :
- BFS avec file de priorité

Floyd-Warshall :
- D matrice carré de taille n
- D[i][j] = distance entre les arrêtes i et j
- on part d'une matrice M0 et on la modifie jusqu'à obtenir
  une matrice Mn = D
- Mk telle que Mk[i][j] = longueur plus court chemin de i à j
  ne passant que par des noeuds entre 1 et k
- M0 = 0 sur les diags et l'infini autre part
- M(k+1)[i][j] = min(Mk[i][j], Mk[i][k+1]+Mk[k+1][j])
               = min(Mk[i][j], M(k+1)[i][k+1]+M(k+1)[k+1][j])
- O(n^3)